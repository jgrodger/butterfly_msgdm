---
title: "Process GAMM analyses with loops"
output: html_document
date: "`r Sys.Date()`"

params:
  analysis: "gamm_models_compare_drop1"
  dataset: "all_species"
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
here::i_am("Scripts/Rmd_Scripts/process_GAMM_analyses.Rmd")
library(tidyverse)
library(tmap)
library(mgcv)
library(gstat)
library(moranfast)
library(knitr)
library(knitrProgressBar)
library(tictoc)
library(here)
library(conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(knitrProgressBar::progress_estimated)
# there is a same-named function in dplyr, check it out
```

#### Parameters for this report
```{r}
print(params)
```

#### Functions
```{r}
# A function to plot normalised residual plots
plot_norm_res <- function(my_gamm, my_gamm_input){
print("Normalized Residual Plots")
resvals <- resid(my_gamm$lme, type = "normalized")
expvals <- fitted(my_gamm$lme)
obsvals <- gamm_input$species.richness
par(mfrow = c(2, 2))
  stats::qqnorm(resvals)
    stats::qqline(resvals)
  plot(resvals~expvals, xlab = "Fitted values", ylab = "Residuals",
   cex = 0.3)
  hist(resvals)
  plot(obsvals ~ expvals, xlab = "Fitted values", ylab = "Observed values",
   cex = 0.3)
}

# a wrapper function to plot variograms
plot_variogram <- function(my_gamm, my_gamm_input){
resvals <- resid(my_gamm$lme, type = "normalized")
var_dat_resid <- variogram(resvals ~1, loc= ~ x + y, data = my_gamm_input)
return(var_dat_resid)
}

```



```{r}
#gamm output has been saved in output already

data_path <- here("Data/Processed_Data/Spatial//" )
gamm_path <-  here(paste0("Output/Spatial/GAM/GAMM_", params$dataset, "//"))
out_path <-  here(paste0("Output/Spatial/GAM/GAMM_", params$dataset, "/", params$analysis, "//"))
if(!dir.exists(out_path)) dir.create(out_path)
```

#load input data and gamm output
```{r}

gamm_input <- readRDS(paste0(data_path, params$dataset, "_gamm_input.rds"))
gamm_list <- readRDS(paste0(gamm_path, params$analysis, ".rds"))


# names(gamm_list) <- c("gamm_corGaus", "gamm_corExp", "gamm_corLin",
# "gamm_corRatio", "gamm_corSpher")
# 
# write_rds(gamm_list , 
#           file = paste0(gamm_path, params$analysis, ".rds"))

list2env(gamm_list,envir = globalenv())
```


#### Find best correlation structure
```{r}


for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
print(AIC(gamm_i$lme))
}
#aic_table <- AIC(gamm_corGaus$lme, gamm_corExp$lme, gamm_corLin$lme, gamm_corRatio$lme, gamm_corSpher$lme) %>%
#  rownames_to_column(var = "GAMM_analysis") 

#aic_table$Correlation_Structure <- c("corGaus", "corExp", "corLin", "corRatio",  "corSpher") # recode corr struct names

#aic_table <- aic_table %>%
#  arrange(AIC) %>%
#  mutate(delta_AIC = AIC - min(AIC))

#kable(aic_table)


#write_csv(aic_table, file = paste0(out_path, "/correlation_structure_aic_table.csv"))

#index_best <- which(aic_table$AIC == min(aic_table$AIC))

#best_gamm <- gamm_list[[index_best]]
```



#### corGaus
```{r}

for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
par(mfrow = c(2, 2))
gam.check(gamm_i$gam)
}
```



### Normalized Residual Plots

#### There is a need to do additional custom residual plots: From gam.check()

from ?gam.check: "Take care when interpreting results from applying this function to a model fitted using gamm. In this case the returned gam object is based on the working model used for estimation, and will treat all the random effects as part of the error. This means that the residuals extracted from the gam object are not standardized for the family used or for the random effects or correlation structure. Usually it is necessary to produce your own residual checks based on consideration of the model structure you have used."


```{r}
for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
plot_norm_res(gamm_i, gamm_input)
}
```


#### Moran's i

```{r}
for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
print("Moran's test  with I value")
print(moranfast(residuals(gamm_i$lme, type = "normalized"), 
          gamm_input$x, gamm_input$y))
}
```

```{r}
for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
print("Overall concurvity")
print(kable(concurvity(gamm_i$gam, full = TRUE), digits = 2, caption = paste0(names(gamm_list[i]), ": Overall Concurvity")))
      
print("worst")
print(kable(concurvity(gamm_i$gam, full = FALSE)$worst, digits = 2, caption = paste0(names(gamm_list[i]), ": Worst Concurvity")))
print("observed")
print(kable(concurvity(gamm_i$gam, full = FALSE)$observed, digits = 2, caption = paste0(names(gamm_list[i]), ": Observed Concurvity")))
print("estimate")
print(kable(concurvity(gamm_i$gam, full = FALSE)$estimate, digits = 2, caption = paste0(names(gamm_list[i]), ": Estimated Concurvity")))
}
```


### GAM summaries

```{r}
for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
print(summary(gamm_i$gam))
}
```


### Smooth Plots with Partial Residuals

### GAM summaries

```{r}
for (i in 1:length(gamm_list)){
gamm_i <- gamm_list[[i]]
print(names(gamm_list[i]))
par(mfrow = c(3, 3))
plot(gamm_i$gam, residuals = TRUE,  shade = TRUE, shift = coef(gamm_i$gam)[1])
}
```

