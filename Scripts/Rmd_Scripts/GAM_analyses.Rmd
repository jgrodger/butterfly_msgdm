---
title: "GAM species richness"
output: html_document

params:
  dataset: "all_species"
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Packages
```{r}
here::i_am("Scripts/Rmd_Scripts/GAM_analyses.Rmd")

library(tidyverse)
library(sf)
library(sp)
library(terra)
library(mgcv)
library(knitr)

library(tmap)


library(mgcViz)
library(magrittr)


library(gstat)


library(knitrProgressBar)
library(tictoc)
library(here)
library(conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(knitrProgressBar::progress_estimated)

# there is a same-named function in dplyr, check it out
```

#### Functions
```{r}
# A function for plotting gam relationships with my preferences


my.plot.gam <- function(gam_object){
plot(gam_object, residuals = TRUE, seWithMean = TRUE, shade = TRUE, shift = coef(gam_object)[1], pages = 2) 
}

# From https://stackoverflow.com/questions/71252509/is-there-a-way-to-get-progress-information-whan-a-chunk-is-running-in-rmarkdown

slow_function <- function(i, .pb=NULL) {  
  update_progress(.pb)  
  Sys.sleep(0.5)  
  i  
}

# create an R6 progress object for
# the number of loops/iterations in the target chunk
```

#### File Paths
```{r}
data_path <- paste0("./Data/Processed_Data/Spatial/", params$dataset, ".rds")

out_path <-  paste0(here("Output/Spatial/GAM"), "/","GAM", "_" , 
                    params$dataset,  "/")

if(!dir.exists(out_path)) dir.create(out_path)
```

#### Data
```{r}
data <- readRDS(here(data_path))

site.by.species <- data$site.by.species
  
site.by.env <- data$site.by.env

site.by.xy <- data$site.by.xy

# gb polygon

gb <- readRDS(here("./Data/Input_Environmental_Data/gb_multipolygon_simplified.rds"))

str(gb, max.level = 1)

crs(gb)
```

#### Parameters for this report
```{r}
print(params)
```

#### Environmental variable, easting, northing and richness Pearson and Spearman correlations
```{r}
site.by.env.and.richness <- cbind(site.by.xy) %>%
  cbind(site.by.env, rowSums(site.by.species)) %>% 
  rename(species.richness = 'rowSums(site.by.species)')
  

t1 <- cor(site.by.env.and.richness)
t2 <- cor(site.by.env.and.richness, method = "spearman")

print("Pearson correlation")
t1
print("Spearman correlation")
t2
```

#### Visualise relationships with eachother and richness
```{r}
pairs(site.by.env.and.richness[,3:11])

pairs(site.by.env.and.richness[,c(1, 2, 11)])
pairs(site.by.env.and.richness[, c(3, 4, 5, 11)])
pairs(site.by.env.and.richness[,c(6, 7, 8, 11)])
pairs(site.by.env.and.richness[c(9, 10, 11)])
```

#### Check species richness distribution
```{r}
hist(site.by.env.and.richness$species.richness)
```
#GAMS

#### Compare GAMs with different families
```{r}
# Gaussian
gam_gaussian <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + 
                s(topographic.wetness) + s(ph) + s(total.n) + s(tree.density) + 
                s(log10.pesticide.risk) + s(log10.humans),  
                data = site.by.env.and.richness, method= "REML")

gam_poisson <- update(gam_gaussian, family = "poisson", link = "log")

gam_tweedie1 <- update(gam_poisson, family = Tweedie(p = 1.01))

gam_tweedie2 <- update(gam_poisson, family = Tweedie(p = 2))



```


# Gaussian
```{r}
summary(gam_gaussian)
par(mfrow = c(2, 2))
gam.check(gam_gaussian)
my.plot.gam(gam_gaussian)
```

#### Poisson
```{r}
summary(gam_poisson)
par(mfrow = c(2, 2))
gam.check(gam_poisson)
my.plot.gam(gam_poisson)
```

##### Tweedie = 1.01
```{r}
summary(gam_tweedie1)
par(mfrow = c(2, 2))
gam.check(gam_tweedie1)
my.plot.gam(gam_tweedie1)
```

##### Tweedie = 2
```{r}
summary(gam_tweedie2)
par(mfrow = c(2, 2))
gam.check(gam_tweedie2)
my.plot.gam(gam_tweedie2)
```



#### Get gam with best AIC. This is gam_tp for thin plate spline that is used with all family options
```{r}
gam_fam_list <-list (gam_gaussian, gam_poisson, gam_tweedie1, gam_tweedie2)

aic_table <- AIC(gam_gaussian, gam_poisson, gam_tweedie1, gam_tweedie2)

kable(aic_table, digits = 2, align = "l")

index_best <- which(aic_table$AIC == min(aic_table$AIC))

# Out of GAMS with different family arguments, the best is...
row.names(aic_table[index_best , ])
gam_tp <- gam_fam_list[[index_best]] 
```
#### Check spline method
```{r}
# cubic regression spline
gam_cr <- update(gam_tp, formula = species.richness ~ s(mean.ann.temp, bs="cr") + 
            s(log10.mean.ann.rain, bs="cr") + s(topographic.wetness, bs="cr") + 
            s(ph, bs="cr") + s(total.n, bs="cr") + s(tree.density, bs="cr") + 
            s(log10.pesticide.risk, bs="cr") + s(log10.humans, bs="cr"))
```



# check p values that (APPROXIMATELY) test null hypothesis that smooth is actually zero
```{r}
summary(gam_tp)$s.pv

summary(gam_cr)$s.pv
```



#### if theses seem likely zero (large p), can try and additional penalty on smooths
```{r}


#Following gam.selection {mgcv}, we use automatic smoothness selection.

# The second approach leaves the original smoothing penalty unchanged, but constructs an additional penalty for each smooth, which penalizes only functions in the null space of the original penalty (the ‘completely smooth’ functions). Hence, if all the smoothing parameters for a term tend to infinity, the term will be selected out of the model. This latter approach is more expensive computationally, but has the advantage that it can be applied automatically to any smooth term. The select argument to gam turns on this method.

# thin plate spline with automatic smoothness selection
#gam_tp_select <- update(gam_tp, select = TRUE)

# cuic regression spline with automatic smoothness selection
#gam_cr_select <- update(gam_cr, select = TRUE)
```


#### Thin plate spline (one with the best family from previous round)
```{r}
summary(gam_tp)
par(mfrow = c(2, 2))
gam.check(gam_tp)
my.plot.gam(gam_tp)
```

#### Cubic regression spline
```{r}
summary(gam_cr)
par(mfrow = c(2, 2))
gam.check(gam_cr)
my.plot.gam(gam_cr)
```



#### Choose the best gam 
```{r}
gam_bs_list <-list (gam_tp,  gam_cr)
aic_table <- AIC(gam_tp,  gam_cr)

kable(aic_table, digits = 2, align = "l")
index_best <- which(aic_table$AIC == min(aic_table$AIC))

gam_best <- gam_bs_list[[index_best]] 
```




```{r}
summary(gam_best)
par(mfrow = c(2, 2))
gam.check(gam_best)
my.plot.gam(gam_best)
```




#### Concurvity tells us about relationships between smoothed terms

#full = TRUE gives overall estimates of relationship of each smoothed term with all others, 
#full = FALSE gives pairwise relationship according to three different methods.

```{r}
concurvity(gam_best, full = TRUE)
print("worst")
round(concurvity(gam_best, full = FALSE)$worst, 2)
print("observed")
round(concurvity(gam_best, full = FALSE)$observed, 2)
print("estimate")
round(concurvity(gam_best, full = FALSE)$estimate, 2)
```



#### Write to disc
```{r}
write_rds(gam_best, file = paste0(here(out_path), "/", params$dataset, "_best_gam.rds"))
```



# Add residuals to xy, and env variables to check patterns
```{r}
residuals <- resid(gam_best)
xy.res <- cbind(site.by.xy, residuals)

env.and.res <- cbind(site.by.env.and.richness, residuals)
```


```{r}
pairs(env.and.res[,c(1, 2, 3, 12)])
pairs(env.and.res[, c(4, 5, 6, 12)])
pairs(env.and.res[, c(7, 8, 9, 12)])
pairs(env.and.res[, c(10, 11, 12)])
```
##### Residual plots show a group of observations with low observed species richness but high predicted species richness

```{r}
plot(residuals ~ mean.ann.temp, data = env.and.res)
plot(residuals ~ mean.ann.temp, data = env.and.res, xlim = c(14, 16.1), ylim = c(-22, -14))

plot(residuals ~ species.richness, data = env.and.res, xlim = c(1, 35), ylim = c(-23, 14))

check.res <-filter(env.and.res, residuals < -14, mean.ann.temp > 14)

plot(residuals ~ species.richness, data = check.res, xlim = c(1, 35), ylim = c(-23, 14))
```

#### Look at geographic pattern in residuals
```{r}
coordinates(env.and.res) <- c("x","y")

crs.geo <- CRS("+init=epsg:27700")  # looks up BNG crs
proj4string(env.and.res) <- crs.geo  # define projection system of our data

coordinates(check.res) <- c("x","y")
proj4string(check.res) <- crs.geo  # define projection system of our data


bubble(env.and.res, "residuals", col = c("black","grey"),
       main = "Residuals", xlab = "X-coordinates", ylab = "Y-coordinates")


bubble(check.res, "residuals", col = c("black","grey"),
       main = "Residuals", xlab = "X-coordinates", ylab = "Y-coordinates")
```


#### Plot Sites
```{r }

basemap <-tm_shape(gb) +
  tm_borders()

pointsmap <- basemap +
tm_shape(env.and.res) +
  tm_symbols(size = 0.25, col = "residuals", midpoint = NA)

print(pointsmap)

checkmap <- basemap +
tm_shape(check.res) +
  tm_symbols(size = 0.25, col = "residuals", midpoint = NA)

print(checkmap)
```

#### check the influence of outliers on the model

```{r}
data.reduced <- as.data.frame(env.and.res)
data.reduced <- data.reduced[ !(data.reduced$residuals < -14 & data.reduced$mean.ann.temp > 14), ]

gam_without_outliers<- update(gam_best,  data = data.reduced)

summary(gam_without_outliers)
plot(gam_without_outliers, seWithMean = TRUE, shade = TRUE, shift = coef(gam_without_outliers)[1], pages = 2)
par(mfrow = c(2, 2))
gam.check(gam_without_outliers)

```




#### Look at geographic pattern in residuals







#So long as the smoothing looks ok, I will not change parameters k and sp from default in s()

#### Check smoothing parameter

```{r}
# gam_sp_minus1 <- update(gam_best, formula = species.richness ~ s(mean.ann.temp, sp = -1) + s(log10.mean.ann.rain, sp = -1) + s(topographic.wetness, sp = -1) + s(ph, sp = -1) + s(total.n, sp = -1) + s(tree.density, sp = -1) + s(log10.pesticide.risk, sp = -1) + s(log10.humans, sp = -1))
# 
# gam_sp01 <- update(gam_best,  formula = species.richness ~ s(mean.ann.temp, sp = 0.1) + s(log10.mean.ann.rain, sp = 0.1) + s(topographic.wetness, sp = 0.1) + s(ph, sp = 0.1) + s(total.n, sp = 0.1) + s(tree.density, sp = 0.1) + s(log10.pesticide.risk, sp = 0.1) + s(log10.humans, sp = 0.1))
#   
# gam_sp001 <-   update(gam_best,  formula = species.richness ~ s(mean.ann.temp, sp = 0.01) + s(log10.mean.ann.rain, sp = 0.01) + s(topographic.wetness, sp = 0.01) + s(ph, sp = 0.01) + s(total.n, sp = 0.01) + s(tree.density, sp = 0.01) + s(log10.pesticide.risk, sp = 0.01) + s(log10.humans, sp = 0.01))

```

##### Default smoothing is fine (and sp = -1 equivalent to sp = NULL)
```{r}
#AIC(gam_best, gam_sp_minus1, gam_sp01, gam_sp001)
```

```{r}
# # Note, k = -1 is the same as k = 10 in these analyses with both bs = "cr" and default bs = "tp"
# 
# # Set k manually k = 10
# # change k
# gam7 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness, k = 20) + s(ph, k = 20) + s(total.n, k = 20) + s(tree.density) + s(log10.pesticide.risk, k = 20) + s(log10.humans),  data = site.by.env.and.richness, method= "REML")
# 
# # change k
# gam8 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness, k = 40) + s(ph, k = 40) + s(total.n, k = 40) + s(tree.density) + s(log10.pesticide.risk, k = 40) + s(log10.humans),  data = site.by.env.and.richness, method= "REML")
# 
# # change k
# gam9 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness, k = 80) + s(ph, k = 80) + s(total.n, k = 40) + s(tree.density) + s(log10.pesticide.risk, k = 80) + s(log10.humans),  data = site.by.env.and.richness, method= "REML")

```

```{r}
# summary(gam7)
# par(mfrow = c(2, 2))
# gam.check(gam7)
```
```{r}
# summary(gam8)
# par(mfrow = c(2, 2))
# gam.check(gam8)
```

```{r}
# summary(gam9)
# par(mfrow = c(2, 2))
# gam.check(gam9)
```

```{r}
#AIC(gam6, gam7, gam8, gam9)
```

```{r}
# visualise the fitted effects of two variables at at time
#vis.gam(gam6, view = c("ph", "total.n"),theta= -135)
#vis.gam(gam6, view = c("ph", "mean.ann.temp"),theta= -45)
#vis.gam(gam6, view = c("ph", "log10.pesticide.risk"),theta= -45)
```


```{r}
# plot(gam8, seWithMean = TRUE, shade = TRUE, shift = coef(gam6)[1], pages = 2)
# vis.gam(gam8, view = c("ph", "total.n"),theta= -135)
# vis.gam(gam8, view = c("ph", "mean.ann.temp"),theta= -45)
# vis.gam(gam8, view = c("ph", "log10.pesticide.risk"),theta= -45)
```







```{r warning = FALSE}
# see answer here for k https://stats.stackexchange.com/questions/359568/choosing-k-in-mgcvs-gam

# 
# pdf(here("./Output/gam.pdf"))
# par(mfrow = c(2,4))
# plot.gam(gam1)
# dev.off()

#gam from zetadiv, Code from Latombe et al. 2018

#including log observations 

#zeta.gam <- Zeta.msgdm(site.by.species, site.by.env,xy=NULL,order=1,sam=50000,normalize = FALSE,reg.type = "gam",family=gaussian(),control=glm.control(maxit = 500),empty.row = "remove",kn=10)


```

# Not needed, using GAMM instead


```{r}
# summary(gam11)
# plot(gam11, seWithMean = TRUE, shade = TRUE, shift = coef(gam11)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam11)
```

```{r}
# summary(gam12)
# plot(gam12, seWithMean = TRUE, shade = TRUE, shift = coef(gam12)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam12)
# 
# summary(gam12)$s.pv
```

```{r}
# summary(gam13)
# plot(gam13, seWithMean = TRUE, shade = TRUE, shift = coef(gam12)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam13)
# 
# summary(gam13)$s.pv
```
# select = TRUE
```{r}
# gam14 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n) + s(tree.density) + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "REML", select = TRUE)
# 
# #method = ML
# gam15 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n) + s(tree.density) + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML", select = TRUE)
# 
# #As for gam6 but with ML
# gam16 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n) + s(tree.density) + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")


```

```{r}
# summary(gam14)
# plot(gam14, seWithMean = TRUE, shade = TRUE, shift = coef(gam12)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam14)
```


```{r}

#check if appropriate to compare reml and ml
#AIC(gam6, gam11, gam12, gam13, gam14, gam15, gam16)

```

# leave out tree density first
```{r}
# gam17 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n)  + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# anova(gam16, gam17, test = "F")
# 
# AIC(gam16, gam17)
# 
# summary(gam17)
# plot(gam17, seWithMean = TRUE, shade = TRUE, shift = coef(gam17)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam17)
```

```{r}
# concurvity(gam17, full = TRUE)
# print("worst")
# round(concurvity(gam17, full = FALSE)$worst, 2)
# print("observed")
# round(concurvity(gam17, full = FALSE)$observed, 2)
# print("estimate")
# round(concurvity(gam17, full = FALSE)$estimate, 2)
```


# check what happens when terms are dropped (note, here we use ML)
```{r}


# 
# # -temp
# gam18 <- gam(species.richness ~  s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n)  + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# # - rain
# gam19 <- gam(species.richness ~ s(mean.ann.temp) + s(topographic.wetness) + s(ph) + s(total.n)  + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# # - wetness
# gam20 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain)  + s(ph) + s(total.n)  + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# # - ph
# gam21 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(total.n)  + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# #- n
# gam22 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph)   + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# # - pesticide
# gam23 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n)  + s(log10.humans),  data = site.by.env.and.richness, method= "ML")
# 
# # - humans
# gam24 <- gam(species.richness ~ s(mean.ann.temp) + s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n)  + s(log10.pesticide.risk),  data = site.by.env.and.richness, method= "ML")

```

```{r}
# 
# # -temp
# anova(gam17, gam18, test = "F")
# 
# # -rain
# anova(gam17, gam19, test = "F")
# 
# # -wetness
# anova(gam17, gam20, test = "F")
# 
# # -ph
# anova(gam17, gam21, test = "F")
# 
# #-n
# anova(gam17, gam22, test = "F")
# 
# # -pesticide
# anova(gam17, gam23, test = "F")
# 
# # -humans
# anova(gam17, gam24, test = "F")
# 
# 
# AIC(gam17, gam18, gam19, gam20, gam21, gam22, gam23, gam24)
```


##### reduce concurvity by leaving out one of pairs of variables with high concurvity (here we go back to REML)
```{r}
# # leave out rainfall (concurv with temp), pesticide risk(concurve with N) and humans (concurv with temp)
# gam25 <- gam(species.richness ~ s(mean.ann.temp) + s(topographic.wetness) + s(ph) + s(total.n)   ,  data = site.by.env.and.richness, method= "REML")
# 
# #leave out temp, pesticide risk, and humans
# 
# gam26 <- gam(species.richness ~ s(log10.mean.ann.rain) + s(topographic.wetness) + s(ph) + s(total.n),  data = site.by.env.and.richness, method= "REML")
# 
# # leave out rainfall, temp and ph
# gam27 <- gam(species.richness ~  s(topographic.wetness)  + s(total.n) + s(tree.density) + s(log10.pesticide.risk) + s(log10.humans),  data = site.by.env.and.richness, method= "REML")
```

```{r}

# summary(gam25)
# plot(gam25, seWithMean = TRUE, shade = TRUE, shift = coef(gam25)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam25)
```

```{r}
# summary(gam26)
# plot(gam26, seWithMean = TRUE, shade = TRUE, shift = coef(gam26)[1], pages = 2)
# par(mfrow = c(2, 2))
# gam.check(gam26)
```

##### If temp, rainfall and ph are left out, opposite relationships are produced for humans and pesticide risk
```{r}
# summary(gam27)
# plot(gam27, seWithMean = TRUE, shade = TRUE, shift = coef(gam27)[1], pages = 3)
# par(mfrow = c(2, 2))
# gam.check(gam27)
```

```{r}
summary(gam_best)
plot(gam_best, seWithMean = TRUE, shade = TRUE, shift = coef(gam_best)[1], pages = 4)
```


# Play with mgcVis
```{r}
vis6 <- getViz(gam_best)

#adapted from https://cran.r-project.org/web/packages/mgcViz/vignettes/mgcviz.html
#We added the fitted smooth effect, rugs on the x and y axes, confidence lines at 95%, partial residual points and we changed the plotting theme to ggplot2::theme_classic. Functions such as l_fitLine or l_rug are effect-specific layers. To see all the layers available for each effect plot we do:

#mul = 2 means interval +- 2 SE shown, narrower than 95% CI of course (default here)
p1 <- plot(sm(vis6, 1))
p1 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p2 <- plot(sm(vis6, 2))
p2 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p3 <- plot(sm(vis6, 3))
p3 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p4 <- plot(sm(vis6, 4))
p4 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p5 <- plot(sm(vis6, 5))
p5 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p6 <- plot(sm(vis6, 6))
p6 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p7 <- plot(sm(vis6, 7))
p7 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

p8 <- plot(sm(vis6, 8))
p8 + l_fitLine(colour = "red") + l_rug(mapping = aes(x=x, y=y), alpha = 0.8) +
    l_ciLine(colour = "blue", linetype = 2) + 
    l_points(shape = 19, size = 1, alpha = 0.1) + theme_classic()

```


```{r}
v1 <-   variogram(residuals ~ 1, loc= ~ x+y, data = xy.res)
fit1 <- fit.variogram(v1, vgm(c("Sph", "Exp"))); 
plot(v1, fit1)

# extract the nugget and range from the variogram model to create the correlation structure 
# to include in the magic formula
kable(fit1)


```



