---
title: "Zeta Msgdm Results Processing"
output: html_document

params:
  dataset: "all_species"
  normalize_msgdm: "Simpson"
  orders_msgdm: 
   - 2
   - 6
   - 10
---

```{r}
here::i_am("Scripts/Rmd_Scripts/process_msgdm_results.Rmd")

library(rmarkdown)
library(tidyverse)
library(zetadiv)
library(knitr)
library(knitrProgressBar)
library(tictoc)
library(gridExtra)
library(conflicted)
library(here)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::rename)
```

#### an example paper with helpful code for generating figures
```{r}
#https://onlinelibrary.wiley.com/doi/10.1111/mec.16860

# For forest plots, in future consider metator::forest, looks easier!!!
#https://www.metafor-project.org/doku.php/plots:forest_plot_with_subgroups
#https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/forest.html
```

#### File Paths
```{r}
# Path to data used for tje msgdm analysis (which is already done)
data_path <- paste0("./Data/Processed_Data/Spatial/", params$dataset, ".rds")

# Path to output of the msgdm analysis
msgdm_path <-  paste0("./Output/Spatial/msgdms", "/", params$dataset, "_" , params$normalize_msgdm, "/", 
                      params$dataset, "_" , params$normalize_msgdm, "_zeta_msgdms.rds")

# Path to folder to save output of this script
out_path <- here(paste0("./Output/Spatial/msgdms", "/", params$dataset, "_" , params$normalize_msgdm, "/", 
                       "/figs_tables//"))

if(!dir.exists(out_path)) dir.create(out_path, recursive = TRUE)
```

#### Load Data
```{r}
my_data <- read_rds(here(data_path))

my_msgdms <- read_rds(here(msgdm_path))

my_env_data <- my_data$site.by.env

# A vector of the orders for msgdms included
my_orders <- params$orders_msgdm
```

#### Extract processed ispline and environmental variable data into a dataframe.
```{r}
# Extract ispline data and environmantal data for each zeta order into a list
all_isplines <- list()
for(i in 1:length(my_orders)){
  temp_out <- Return.ispline(msgdm = my_msgdms[[i]], data.env = my_env_data, 
                  distance = TRUE) # Extract isplines and associated data
  # Normalised environmental data
  temp_env <- temp_out$env %>%
    rownames_to_column(var = "site")
  # Ispline predicted change in zeta diversity with environmental variable
  temp_isplines <- temp_out$Ispline
    names(temp_isplines) <- paste0("f.of.", names(temp_isplines)) #rename columns
    temp_isplines <- temp_isplines %>%
    mutate(zeta_order = paste0("zeta_", my_orders[i])) %>% #adding zeta_order as a column
    mutate(zeta_order = factor(zeta_order, levels = paste0("zeta_", my_orders))) %>%   
    relocate(zeta_order) %>%  
    cbind(temp_env) %>%
    relocate(site, .after = zeta_order) 
       
  all_isplines[[i]] <- temp_isplines
}


# Change from list to single dataframe, so that I can group by predictors for plots
all_isplines <- bind_rows(all_isplines) 
```

#### I haven not yet managed to get plots of isplines against environmental data 
#### on the original scale
```{r}
# to do this, check downloaded code. If that doesn't help, add to questions for Guillaume


# head(temp_out$env)
# head(temp_out$env.num)
# 
# head(temp_env)
# 
# head(temp_isplines)


# mins <- temp_out$env.num %>%
#   summarise(across(where(is.numeric), min))
# maxs <- temp_out$env.num %>%
#   summarise(across(where(is.numeric), max)) 
# 
# env_diffs <- data.frame(t(maxs-mins))
# names(env_diffs) <- "max_possible_difference"

```

#### Plot isplines for each predictor for different zeta orders
```{r}
for(i in 1:(ncol(my_env_data) + 1)){
  print(
    ggplot(data = all_isplines, aes(x = all_isplines[, (i + 11)], 
                                  y = all_isplines[,(i + 2)], group = zeta_order)) +
    geom_line(aes(colour = zeta_order))  + 
    xlab(names(all_isplines)[i + 11]) + 
    ylab("Change in Zeta diversity")
  )
}
```

#### Extract coefficients for each zeta order
```{r}
# Extract coefficients for each zeta order into a list
all_coef <- list()
for(i in 1:length(my_orders)){
  temp_summary <- summary(my_msgdms[[i]]$model)
  
  temp_coef <- rep(paste0("zeta_order", i), nrow(temp_summary$coefficients)) %>%
    data.frame() %>%
    rename(zeta_order = ".") %>%
    cbind(temp_summary$coefficients) %>%
    rename(p_value = "Pr(>|z|)",
      z_value = "z value",
      Std_Error = "Std. Error") %>% 
    rownames_to_column(var = "Effect")   %>% 
    mutate(Effect = factor(Effect, levels = Effect),
    zeta_order = paste0("zeta_", my_orders[i]),#adding zeta_order as a column
      Lower = Estimate - 1.96*Std_Error, #CL
      Upper = Estimate + 1.96*Std_Error,
      colours = factor(c(1, rep(2:10, each = 3))), #To generalise, this will need to be changed
      y_height = as.numeric(rev(seq(1,28))))
  
  all_coef[[i]] <- temp_coef
}

check<- bind_rows(all_coef)
```

#### Make a forest plot for each zeta order and store in a list.
```{r}
forest_plots <- list()

for (i in 1:length(my_orders)){

plot_data <- all_coef[[i]] 

p <- ggplot(plot_data, aes(x = Estimate, y = y_height)) +
  geom_point(aes(colour = colours)) +                                     
  geom_pointrange (aes(xmin = Lower, xmax = Upper, colour = colours)) + 
  scale_y_continuous(name = NULL, breaks = plot_data$y_height,
    labels = plot_data$Effect) +
  ggtitle(paste0("Zeta = ", my_orders[i])) +
  theme_bw() +
  theme(panel.border = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line.x = element_line(),
    axis.line.y = element_blank(),
    axis.text.x = element_text(colour = "black", size = 11),
    axis.text.y = element_blank(),
    #axis.text.y = element_text(colour = "black", size = 10),
    axis.ticks.x = element_line(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_text(), 
    plot.title = element_text(hjust = 0, face = "bold"),
  legend.position="none")  +  
  geom_vline(xintercept = 0, color = "red",linetype = "dashed", alpha = 0.5) 

forest_plots[[i]] <- p
}

```

# Make a table with names of predictor splines and intercept to add to forest plot
```{r}
table_base <- 
  ggplot(data = all_coef[[1]], aes(y = y_height)) + # everything in this plot is empty 
  ylab(NULL) + xlab('') + ggtitle('') + 
  ylim(0, 28) + # make sure this is the same as p1
  theme(panel.border = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_text(color = "white", hjust = -3, size = 11),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust = 0, face = "bold"),# make sure hjust is the same as p1
    legend.position = "none") 
```

#### A table for effect names (to be improved for presentation), font size 10
```{r}
effects_table <- table_base + 
  geom_text(aes(y = y_height, 
                x = 0, 
                colour = colours,
                label = Effect), 
            size = 3.1, hjust = 1, vjust = -0.5) +
            xlim(-2,0) +
            ggtitle("Effect")  + 
            theme(plot.title = element_text(size = 10, face = "bold"))
```


#### A table for effect names (to be improved for presentation), default font size
```{r}
effects_table2 <- table_base + 
  geom_text(aes(y = y_height, 
                x = 0, 
                colour = colours,
                label = Effect), 
            size = 3.1, hjust = 1, vjust = -0.5) +
            xlim(-2,0) +
            ggtitle("Effect")
```

#### A list of tables of p values to combine with forest plots
```{r}
p_tables <- list()

for (i in 1:length(my_orders)){
p_table <- table_base + 
  geom_text(data = all_coef[[i]],
    aes(y = y_height, 
        x = 0, 
        colour = colours,
        label = paste0(format(round(p_value, digits = 3), nsmall = 3))), 
        size = 3.1, hjust = 0, vjust = -0.5)  +
        xlim(0,1) +
        ggtitle('')

p_tables[[i]] <- p_table
}
```


#### A list of tables of p values with headings to combine with forest plots
```{r}

p_tables2 <- list()

for (i in 1:length(my_orders)){
p_table <- table_base + 
  geom_text(data = all_coef[[i]],
    aes(y = y_height, 
        x = 0, 
        colour = colours,
        label = paste0(format(round(p_value, digits = 3), nsmall = 3))), 
    size = 3.1, hjust = 0, vjust = -0.5)  +
    xlim(0,1) +
    ggtitle(paste0("Zeta = ", my_orders[i])) + 
    theme(plot.title = element_text(size = 10, face = "bold"))

p_tables2[[i]] <- p_table
}
```

#### Separate forest plots with p values for each zeta order
```{r}
for (i in 1:length(my_orders)){
grid.arrange(effects_table, p_tables[[i]], forest_plots[[i]], 
             nrow = 1, ncol = 3)
}
```

#### Makes lists for plotting forest plots for different isplines together
```{r}
# Labels for effects with the heading in different font sizes to match
effects_table <- list(effects_table)
effects_table2 <- list(effects_table2)

# List for forest plot
forest_plots <- c(effects_table2, forest_plots)

# List of p values corresponding to forest plots for plotting separately
p_tables <- c(effects_table, p_tables)
# List of p values corresponding to forest plots for plotting together
p_tables2 <- c(effects_table, p_tables2)
```

#### Forest plot
```{r}
grid.arrange(grobs = forest_plots,
              nrow = 1, ncol = length(forest_plots))

filepath <- paste0(out_path, "/forest_plot", ".png")
unlink(filepath, recursive = FALSE, force = FALSE) #deletes previous version with the same name
png(file = filepath, 
   width = 55*length(forest_plots),
   height = 210, 
   units = "mm", 
   res = 72)
grid.arrange(grobs = forest_plots,
              nrow = 1, ncol = length(forest_plots))

dev.off()
```

#### Table of p values for all zeta orders
```{r}
grid.arrange(grobs = p_tables2,
              nrow = 1, ncol = length(p_tables))

filepath <- paste0(out_path, "/forest_plot_p_values", ".png")
unlink(filepath, recursive = FALSE, force = FALSE) #deletes previous version with the same name
png(file = filepath, 
   width = 55*length(p_tables2),
   height = 210, 
   units = "mm", 
   res = 72)
grid.arrange(grobs = p_tables2,
              nrow = 1, ncol = length(p_tables2))
dev.off() 
```

#### Check if we can retrieve the same ispline plots
```{r}
my_msgdm_i <- my_msgdms[[1]]

my_data.env <- my_data$site.by.env

my_isplines <- Return.ispline(msgdm = my_msgdm_i, data.env = my_data.env, distance = TRUE)

# These two are almost identical except that the quantiles for distance are 
# slightly different
Plot.ispline(msgdm = my_msgdm_i, data.env = my_data.env, distance = TRUE)
Plot.ispline(isplines = my_isplines)

str(my_isplines, max.level = 1)
str(my_msgdms, max.level = 1)

isp_env <- my_isplines$env

head(my_isplines$Ispline)
```


#### Deviance explained (rough as this is a non-linear model)

```{r}
dev_table <- data.frame()

for (i in 1:length(params$orders_msgdm)) {
dev_table[i, 1] <- paste0("Zeta = ", my_orders[[i]])
dev_table[i, 2] <- with(summary(my_msgdms[[i]]$model), 1 - deviance/null.deviance)
}
names(dev_table) <- c("Zeta order", "Deviance Explained")

#I have checked and csv over-writes fines
write_csv(dev_table, file = paste0(out_path, "/", "deviance_table.csv"))
kable(dev_table, digits = 3)
```

#### Variation explained table (also rough)
```{r}
# make the table for output

# First column is the source of variation
source <- c("Environment", "Distance", "Environment or Distance", "Total")
varparts <- data.frame(source)
names(varparts) <- "Source of Variation"

# remaining columns are the variation explained for each zeta order
for (i in 1:length(params$orders_msgdm)) {
  set.seed(1)
  zetavar <- Zeta.varpart(msgdm.mod = my_msgdms[[i]], method.glm = "glm.fit2", cons.inter = -1)
  zetavar <- 100*zetavar[, 1]  %>%
  round(3)
#formatting step needed for digits after decimal
zetavar <- formatC(zetavar, 1, format = "f")
  
varparts[, i+1] <-  c( zetavar[6], zetavar[4], zetavar[5], zetavar[1])
names(varparts)[i + 1] <- paste0("Percentage Explained for Zeta order ", params$orders_msgdm[i])

}

varparts

varpart_out <- list(varpart_caption, varparts)
names(varpart_out) <- c("caption", "table")

write_rds(varpart_out, file = paste0(out_path, "variance_partitioning_table.rds"))

write_csv(varparts, file = paste0(out_path, "variance_partitioning_table.csv"))

out_path
```


## Contributions to Variation in zeta diversity 


# to do here: change so I can see wider countryside and habitat specialists with different colours/symbols

#contribution to variance of zeta 
```{r}
occ.df<- data.frame( cbind(colSums(site.by.species), colSums(site.by.species)/nrow(site.by.species)))

names(occ.df) <- c("occ", "p.occ")


# here I am trying to work out relative influence of different species on zeta diversity in relation to their occupancy
#commented out
#probability that species is shared between n sites in one sample but not shared between n sites in a second sample
occ.df <- occ.df %>% 
  mutate(rare.cat = case_when(p.occ < 0.2 ~ "1.rare",
                              p.occ >=0.2 & p.occ < 0.4 ~ "2.med.rare",
                              p.occ >=0.4 & p.occ < 0.6 ~ "3.med", 
                              p.occ >= 0.6 & p.occ < 0.8 ~ "4.med.common",
                              p.occ >= 0.8 ~ "5.common")#,
   # share2 = (p.occ1^2)*(1-p.occ1^2),
   #      share3 = (p.occ1^3)*(1-p.occ1^3),
    #     share4 = (p.occ1^4)*(1-p.occ1^4),
     #    share5 = (p.occ1^5)*(1-p.occ1^5),
  #       share10 = (p.occ1^10)*(1-p.occ1^10),
   #      share15 = (p.occ1^15)*(1-p.occ1^15),
  #       share20 = (p.occ1^20)*(1-p.occ1^20),
  #       share30 = (p.occ1^30)*(1-p.occ1^30),
  #       share50 = (p.occ1^50)*(1-p.occ1^50),
  #       share100 = (p.occ1^100)*(1-p.occ1^100),
  #       share200 = (p.occ1^200)*(1-p.occ1^200)
    )

hist(occ.df$p.occ, breaks = 20)


#share2 is the probability that species is shared between 2 sites in one sample but not shared between 2 sites in a second sample









```

```{r}
#I have tweaked the Zeta.order.ex function to include the varmat in the output

Zeta.order.ex.2 <- function (data.spec, order = 1, sd.correct = TRUE, rescale = FALSE, 
    empty.row = "empty") 
{
    if (empty.row == "remove") {
        data.spec <- data.spec[-which(rowSums(data.spec) == 0), 
            ]
    }
    if (order > dim(data.spec)[1]) {
        stop("Error: wrong value for \"order\": it must be equal or lower than the number of sites.")
    }
    data.spec <- as.matrix(data.spec)
    intercept_mat <- t(data.spec) %*% data.spec
    occupancy <- colSums(data.spec)
    p <- exp(lchoose(occupancy, order) - lchoose(nrow(data.spec), 
        order))
    zeta.val <- sum(p)
    varmat <- exp(lchoose(intercept_mat, order) - lchoose(nrow(data.spec), 
        order))
    for (j in 1:length(occupancy)) {
        for (k in 1:length(occupancy)) {
            varmat[j, k] <- varmat[j, k] - p[j] * p[k]
        }
    }
    if (sd.correct == TRUE) {
        zeta.val.sd <- sqrt(sum(varmat) * choose(nrow(data.spec), 
            order)/(choose(nrow(data.spec), order) - 1))
    }
    else {
        zeta.val.sd <- sqrt(sum(varmat))
    }
    zeta.order <- list()
    zeta.order$zeta.order <- order
    zeta.order$combinations <- choose(x <- dim(data.spec)[1], 
        order)
    zeta.order$zeta.val <- zeta.val
    zeta.order$zeta.val.sd <- zeta.val.sd
    zeta.order$varmat <- varmat
        return(zeta.order)
}


# a function to get the rowsums for each species in the varmat normalised by variance (sumo of whole matrix)and add to a dataframe which should already have the occupancy and possibly rowsums for other orders of zeta.
#normalised rowsums of the varmat are supposed to represent contribution of each species to variation in zeta diversity so that occupancy can be plotted against contribution to zeta for differnt orders of zeta

# arguments are: site by species matrix, zeta order, name for new variable of normalised rowsums of varmat for each species, data frame to merge the new variable into

get.var.share <- function(data.spec, ord, new.var.name, data.occ){
  
  z <-  Zeta.order.ex.2(data.spec, order = ord)


df1 <- data.frame(z$varmat)

df2<- data.frame(rowSums(df1)/sum(df1))

names(df2)<- new.var.name

out.df <- merge(data.occ, df2, by = "row.names")

out.df<- column_to_rownames(out.df, "Row.names")


return(out.df)

}

#occ.df1<- column_to_rownames(occ.df1, "Row.names")



```



# to do here: change so I can see wider countryside and habitat specialists with different colours/symbols

#contribution to variance of zeta 
```{r}
occ.df<- data.frame( cbind(colSums(site.by.species), colSums(site.by.species)/nrow(site.by.species))) %>%
  rownames_to_column(var = "species.no")

names(occ.df) <- c("species.no", "occ", "p.occ")

occ.df <- merge(species, occ.df, by = "species.no")


# here I am trying to work out relative influence of different species on zeta diversity in relation to their occupancy
#commented out
#probability that species is shared between n sites in one sample but not shared between n sites in a second sample
occ.df <- occ.df %>% 
  mutate(rare.cat = case_when(p.occ < 0.2 ~ "1.rare",
                              p.occ >=0.2 & p.occ < 0.4 ~ "2.med.rare",
                              p.occ >=0.4 & p.occ < 0.6 ~ "3.med", 
                              p.occ >= 0.6 & p.occ < 0.8 ~ "4.med.common",
                              p.occ >= 0.8 ~ "5.common"),
  # # binomial variance proportional to p(1-p) and here p is the probability of being in i sites
           ex.share.2 = (p.occ^2)*(1-p.occ^2),
         ex.share.3 = (p.occ^3)*(1-p.occ^3),
         ex.share.4 = (p.occ^4)*(1-p.occ^4),
         ex.share.5 = (p.occ^5)*(1-p.occ^5),
         ex.share.6 = (p.occ^6)*(1-p.occ^6),
         ex.share.7 = (p.occ^7)*(1-p.occ^7),
         ex.share.8 = (p.occ^8)*(1-p.occ^8), 
         ex.share.9 = (p.occ^9)*(1-p.occ^9),
         ex.share.10 = (p.occ^10)*(1-p.occ^10),
         ex.share.15 = (p.occ^15)*(1-p.occ^15),
         ex.share.20 = (p.occ^20)*(1-p.occ^20),
         ex.share.30 = (p.occ^30)*(1-p.occ^30),
        ex.share.40 = (p.occ^40)*(1-p.occ^40),
         ex.share.50 = (p.occ^50)*(1-p.occ^50)
         
    )

#normalise expected share of variance by column sums

occ.df[, 10:23] <- lapply(occ.df[, 10:23], function(x) x/sum(x))

# I need species no as row names again for functions below
occ.df<- column_to_rownames(occ.df, var = "species.no")

hist(occ.df$p.occ, breaks = 20)


#share2 is the probability that species is shared between 2 sites in one sample but not shared between 2 sites in a second sample









```



```{r}


ggplot(occ.df, aes(x=p.occ, y=ex.share.2, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 2", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.3, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 3", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.4, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 4", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.5, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 5", x = "Occupancy", y = "Expected Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=ex.share.6, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 6", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.7, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 7", x = "Occupancy", y = "Expected Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=ex.share.8, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 8", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.9, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 9", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.10, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 10", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.15, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 15", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.20, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 20", x = "Occupancy", y = "Expected Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=ex.share.30, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 30", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.40, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 40", x = "Occupancy", y = "Expected Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=ex.share.50, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 50", x = "Occupancy", y = "Expected Variance Contribution")
```

```{r}
sp.occ.table <- occ.df[, c(1:4, 7)] 

sp.occ.table <- sp.occ.table[base::order(-sp.occ.table$p.occ), ]

df[order(-df$var1), ]
```



```{r}
occ.df <- get.var.share(site.by.species, 2, "share.2", occ.df)


occ.df <- get.var.share(site.by.species, 3, "share.3", occ.df)
occ.df <- get.var.share(site.by.species, 4, "share.4", occ.df)
occ.df <- get.var.share(site.by.species, 5, "share.5", occ.df)
occ.df <- get.var.share(site.by.species, 6, "share.6", occ.df)
occ.df <- get.var.share(site.by.species, 7, "share.7", occ.df)
occ.df <- get.var.share(site.by.species, 8, "share.8", occ.df)
occ.df <- get.var.share(site.by.species, 9, "share.9", occ.df)
occ.df <- get.var.share(site.by.species, 10, "share.10", occ.df)
occ.df <- get.var.share(site.by.species, 15, "share.15", occ.df)
occ.df <- get.var.share(site.by.species, 20, "share.20", occ.df)
occ.df <- get.var.share(site.by.species, 30, "share.30", occ.df)
occ.df <- get.var.share(site.by.species, 40, "share.40", occ.df)
occ.df <- get.var.share(site.by.species, 50, "share.50", occ.df)
```



```{r}


ggplot(occ.df, aes(x=p.occ, y=share.2, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 2", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.3, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 3", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.4, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 4", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.5, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 5", x = "Occupancy", y = "Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=share.6, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 6", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.7, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 7", x = "Occupancy", y = "Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=share.8, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 8", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.9, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 9", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.10, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 10", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.15, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 15", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.20, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 20", x = "Occupancy", y = "Variance Contribution")



ggplot(occ.df, aes(x=p.occ, y=share.30, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 30", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.40, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 40", x = "Occupancy", y = "Variance Contribution")


ggplot(occ.df, aes(x=p.occ, y=share.50, fill=strategy)) + geom_point(shape=21, size = 3) + 
  scale_fill_manual(values=c("blue", "green")) +
   labs(title="Zeta = 50", x = "Occupancy", y = "Variance Contribution")

```



```{r}
plot(share.2~p.occ, data = occ.df)
plot(share.3~p.occ, data = occ.df)
plot(share.4~p.occ, data = occ.df)
plot(share.5~p.occ, data = occ.df)
plot(share.6~p.occ, data = occ.df)
plot(share.7~p.occ, data = occ.df)
plot(share.8~p.occ, data = occ.df)
plot(share.9~p.occ, data = occ.df)
plot(share.10~p.occ, data = occ.df)
plot(share.15~p.occ, data = occ.df)
plot(share.20~p.occ, data = occ.df)
plot(share.30~p.occ, data = occ.df)
plot(share.40~p.occ, data = occ.df)
plot(share.50~p.occ, data = occ.df)
```



#what I am trying to do here is obtain a measure of the influence of species in different rareness/commonness categories
```{r}
sum.influence <- occ.df %>%
  group_by(rare.cat) %>%
  summarise(category.influence.2 = sum(share.2),
            category.influence.3 = sum(share.3),
            category.influence.4 = sum(share.4),
            category.influence.5 = sum(share.5),
            category.influence.6 = sum(share.6),
            category.influence.7 = sum(share.7),
            category.influence.8 = sum(share.8),
            category.influence.9 = sum(share.9),
            category.influence.10 = sum(share.10),
            category.influence.15 = sum(share.15),
            category.influence.20 = sum(share.20),
            category.influence.30 = sum(share.30),
            category.influence.50 = sum(share.50)
           )


#the below is to normalise when columns do not already sum to one

#https://stackoverflow.com/questions/32276887/use-of-lapply-sd-in-data-table-r

#library(data.table)
#sum.influence2 <- data.table(sum.influence)

#make a vector of column names
#numeric_cols <- names(sum.influence)[sapply(sum.influence, is.numeric)]

#sum.influence2[, lapply(.SD, function(x) x/sum(x)), .SDcols = numeric_cols]

# if you want to update by reference
#sum.influence2[, (numeric_cols) := lapply(.SD, function(x) x/sum(x)), .SDcols = numeric_cols]

```


```{r}
plot(category.influence.2 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))


plot(category.influence.3 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.4 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.5 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.6 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.7 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.8 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.9 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))

plot(category.influence.10 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.20 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.30 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))
plot(category.influence.50 ~ factor(rare.cat), data = data.frame(sum.influence), ylim = c(0, 1))



```


```{r}

sum.influence3 <- sum.influence %>%
  pivot_longer(!rare.cat, names_to = "zeta.order", values_to = "influence")


ggplot(sum.influence3, aes(x=rare.cat, y=influence)) + 
         geom_point(aes(color = factor(zeta.order), size = 2.5)) 

```



<!-- ```{r} -->
<!-- Zeta.order.mc -->
<!-- ``` -->


<!-- ## try to set up k-fold cross validation -->

<!-- ## first an msgdm for training data -->
<!-- ```{r} -->
<!-- set.seed(1) -->
<!-- sites$fold <- kfold(sites, k=5, by = sites$country) -->

<!-- #this shows that the "by"argument works as I understand. It stratifies the sampling -->
<!-- sum <- sites %>% -->
<!--   group_by(fold, country) %>% -->
<!--   summarise(n= n()) -->

<!-- #subset to first fold -->
<!-- S.SP <- site.by.species[sites$fold != 1 ,] -->

<!-- S.XY <- site.by.xy[sites$fold != 1 ,] -->

<!-- S.E <- site.by.env[sites$fold != 1 ,]   -->



<!-- set.seed(1) -->
<!-- msgdm.train <-  Zeta.msgdm(S.XY, data.spec = S.SP, data.env = S.E,  order=2, sam=5000, -->
<!--   reg.type="ispline", normalize="Simpson", family=binomial(link="log"),cons.inter = -1, glm.init = TRUE)  -->


<!-- ``` -->
<!-- ## here i do an entire msgdm for the holdout data because I can't see another way to get the transformed values for distance -->

<!-- ```{r} -->

<!-- S.SP1 <- site.by.species[sites$fold == 1 ,] -->

<!-- S.XY1 <- site.by.xy[sites$fold == 1 ,] -->

<!-- S.E1 <- site.by.env[sites$fold == 1 ,]   -->

<!-- z.test2 <- Zeta.msgdm(S.XY1, data.spec = S.SP1, data.env = S.E1,  order=2, sam=5000, -->
<!--   reg.type="ispline", normalize="Simpson", family=binomial(link="log"),cons.inter = -1, glm.init = TRUE) -->

<!-- test.predictors<- z.test2$predictors -->



<!-- pred.zeta <- Predict.msgdm(model.msgdm = msgdm.test$model, reg.type = "ispline", newdata =  test.predictors) -->

<!-- m1 <- lm (z.test2$val ~ pred.zeta) -->

<!-- summary(m1) -->
<!-- anova(m1) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- Plot.ispline(msgdm = msgdm.train, data.env = S.E, distance = TRUE,  legend = TRUE) -->

<!-- Plot.ispline(msgdm = z.test2, data.env = S.E1, distance = TRUE,  legend = TRUE) -->

<!-- ``` -->
<!-- ```{r} -->
<!-- #Zeta.varpart -->

<!-- print("ZETA 2") -->
<!-- summary(msgdm.train$model) -->
<!-- summary(z.test2$model) -->


<!-- ``` -->

<!-- ```{r} -->

<!-- summary(msgdm.train$model) -->
<!-- summary(z.test2$model) -->
<!-- print("variance explained zeta 2") -->
<!-- with(summary(msgdm.train$model), 1 - deviance/null.deviance) -->
<!-- with(summary(z.test2$model), 1 - deviance/null.deviance) -->
<!-- ``` -->








<!-- ```{r} -->
<!-- z2 <- Zeta.order.mc(data.spec = S.SP, xy = S.XY, sam = 2000, order = 2, normalize = "Simpson") -->
<!-- str(z2) -->
<!-- ``` -->

<!-- ## we need to get the Isplines, which ar -->


<!-- ## use ispline to transfrom data for input to predict -->



<!-- ```{r} -->

<!-- ``` -->



