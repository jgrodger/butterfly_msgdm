---
title: "Zeta Msgdm Results Processing"
output: html_document

params:
  dataset: "all_species"
  normalize_msgdm: "Simpson"
  orders_msgdm: 
   - 2
   - 3
---

```{r}
here::i_am("Scripts/Rmd_Scripts/butterfly_msgdm_tables_figures_report.Rmd")

library(rmarkdown)
library(tidyverse)
library(zetadiv)
library(knitr)
library(knitrProgressBar)
library(tictoc)
library(gridExtra)
library(conflicted)
library(here)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::rename)
```
#### File Paths
```{r}
data_path <- paste0("./Data/Processed_Data/Spatial/", params$dataset, ".rds")

# msgdm output
msgdm_path <-  paste0("./Output/Spatial/msgdms", "/", params$dataset, "_" , params$normalize_msgdm, "/", 
                      params$dataset, "_" , params$normalize_msgdm, "_zeta_msgdms.rds")

# out_path
out_path <- here(paste0("./Output/Spatial/msgdms", "/", params$dataset, "_" , params$normalize_msgdm, "/", 
                       "/figs_tables/"))

if(!dir.exists(out_path)) dir.create(out_path, recursive = TRUE)
```

```{r}
msgdm_path <-  "./Output/Spatial/msgdms/wc_Simpson/wc_Simpson_zeta_msgdms.rds"

my_msgdms <- read_rds(here(msgdm_path))


```


#https://onlinelibrary.wiley.com/doi/10.1111/mec.16860
```{r}
my_data <- read_rds(here(data_path))

my_msgdms <- read_rds(here(msgdm_path))

my_env_data <- my_data$site.by.env

my_msgdms$orders <- c(2, 3, 4, 6, 10, 15, 20, 50)

#to do later get quantiles of env vars


#this will need to be made flexible later
my_orders <- params$orders

all_isplines <- list()

#get ispline predicted change in zeta diversity and env variables from results
for(i in 1:length(my_orders)){
     temp_out <- Return.ispline(msgdm = my_msgdms[[i]], data.env = my_env_data, 
                  distance = TRUE) #extract isplines and associated data using the package function
     
     temp_env <- temp_out$env %>%
       rownames_to_column(var = "site") #%>% 
     #  mutate(distance = temp_out$env$distance)
     
     temp_isplines <- temp_out$Ispline #extract the Isplines into the list
      names(temp_isplines) <- paste0("f.of.", names(temp_isplines)) #rename columns
      temp_isplines <- temp_isplines %>%
      mutate(zeta_order = paste0("zeta_", my_orders[i])) %>% #adding zeta_order as a column
      mutate(zeta_order = factor(zeta_order, levels = paste0("zeta_", my_orders)))  %>%   
      relocate(zeta_order)   %>%  
      cbind(temp_env) %>%
      relocate(site, .after = zeta_order) 
       
     all_isplines[[i]] <- temp_isplines
}


# Change from list to single dataframe
all_isplines <- bind_rows(all_isplines) 

```

#### get environmental variables on the original scale
```{r}
# to do this, check do downloaded code. If that doesn't help, add to questions for Guillaume


# head(temp_out$env)
# head(temp_out$env.num)
# 
# head(temp_env)
# 
# head(temp_isplines)


# mins <- temp_out$env.num %>%
#   summarise(across(where(is.numeric), min))
# maxs <- temp_out$env.num %>%
#   summarise(across(where(is.numeric), max)) 
# 
# env_diffs <- data.frame(t(maxs-mins))
# names(env_diffs) <- "max_possible_difference"

```


#### Check if the msgdm output can be reproduced from this dataframe using ggplot

#### to do, use raw rather than standardised predictor values
```{r}

for(i in 1:(ncol(my_env_data) + 1)){
  
  
  
print(
  ggplot(data = all_isplines, aes(x = all_isplines[, (i + 11)], 
                                  y = all_isplines[,(i + 2)], group = zeta_order)) +
   geom_line(aes(colour = zeta_order))  + 
    xlab(names(all_isplines)[i + 11]) + 
  ylab("Change in Zeta diversity")
)
}


 # y_var <- names(all_isplines)[i+2]
 # x_var <- names(all_isplines)[i+11] 
```

#### Summaries of statistisal results, p values needed to interpret ispline plots and forest plots better
```{r}

all_coef <- list()

for(i in 1:length(my_orders)){
    temp_summary <- summary(my_msgdms[[i]]$model)
    temp_coef <- rep(paste0("zeta_order", i), nrow(temp_summary$coefficients)) %>%
      data.frame() %>%
      rename(zeta_order = ".") %>%
      cbind(temp_summary$coefficients) %>%
      rename(p_value = "Pr(>|z|)",
             z_value = "z value",
             Std_Error = "Std. Error") %>% 
      rownames_to_column(var = "Effect")   %>% 
      mutate(Effect = factor(Effect, levels = Effect),
            zeta_order = paste0("zeta_", my_orders[i]),#adding zeta_order as a column
           Lower = Estimate - 1.96*Std_Error, #CL
           Upper = Estimate + 1.96*Std_Error,
           colours = factor(c(1, rep(2:10, each = 3))), #To generalise, this will need to be changed
           y_height = as.numeric(rev(seq(1,28))))
    all_coef[[i]] <- temp_coef
}

all_coef <- bind_rows(all_coef)%>% 
      mutate(zeta_order = factor(zeta_order)) # change from list to single dataframe
```

#### Effect size plot, consider metator::forest, easier!!!
#https://www.metafor-project.org/doku.php/plots:forest_plot_with_subgroups
#https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/forest.html
```{r}
# Credit to https://yzwisalaity.github.io/Forest-Plot/,  https://rgraphs.com/high-quality-forest-plots-in-r-ggplot2/

split_coef <- split(all_coef, f = all_coef$zeta_order)

forest_plots <- list()

for (i in 1:length(my_orders)){
plot_data <- split_coef[[i]] 

p <- ggplot(plot_data, aes(x = Estimate, y = y_height)) +
        geom_point(aes(colour = colours)) +                                     
        geom_pointrange (aes(xmin = Lower, xmax = Upper, colour = colours)) + 
         scale_y_continuous(name = NULL, breaks = plot_data$y_height,
              labels = plot_data$Effect) +
    ggtitle(paste0("Zeta = ", my_orders[i])) +
  theme_bw() +
 theme(panel.border = element_blank(),
      panel.background = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line.x = element_line(),
      axis.line.y = element_blank(),
      axis.text.x = element_text(colour = "black", size = 11),
      axis.text.y = element_blank(),
      #axis.text.y = element_text(colour = "black", size = 10),
      axis.ticks.x = element_line(),
        axis.ticks.y = element_blank(),
      axis.title.x = element_text(), 
      plot.title = element_text(hjust = 0, face = "bold"),
      legend.position="none")  +  
      geom_vline(xintercept = 0, color = "red",linetype = "dashed", alpha = 0.5) 
forest_plots[[i]] <- p
}

```

# Make a table in ggplot to align with forest plot
```{r}
table_base <- 
  ggplot(data = split_coef[[1]], aes(y = y_height)) + # everything in this plot is empty 
  ylab(NULL) + xlab('') + ggtitle('') + 
  ylim(0, 28) + # make sure this is the same as p1
  theme(panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.text.x = element_text(color = "white", hjust = -3, size = 11),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(hjust = 0, face = "bold"),# make sure hjust is the same as p1
        legend.position = "none") 

```

#### A table for effect names (to be improved for presentation)
```{r}
t1 <- table_base + 
  geom_text(aes(y = y_height, 
                x = 0, 
                colour = colours,
                label = Effect), 
                size = 3.1, hjust = 1, vjust = -0.5)  +
            xlim(-2,0) +
            ggtitle('') 

#t1
```

#### A list of tables of p values to combine with forest plots
```{r}

p_tables <- list()

for (i in 1:length(my_orders)){
p_table <- table_base + 
  geom_text(data = split_coef[[i]],
    aes(y = y_height, 
                x = 0, 
                colour = colours,
                label = paste0(format(round(p_value, digits = 3), nsmall = 3))), 
                size = 3.1, hjust = 0, vjust = -0.5)  +
            xlim(0,1) +
            ggtitle('') 
p_tables[[i]] <- p_table


}

```

```{r}

for (i in 1:length(my_orders)){
grid.arrange(t1, p_tables[[i]], forest_plots[[i]], 
             nrow = 1, ncol = 3)
}
```

#### lists for plotting
```{r}
# This has to be a list to be added to existing lists
ispline_names <- list(t1)

# List for forest plot
forest_plots <- c(ispline_names, forest_plots)

# List of p values corresponding to forest plots
p_tables <- c(ispline_names, p_tables)

```

#### Forest plot. Need to get sizing right! text cut off in png
```{r}

grid.arrange(grobs = forest_plots,
              nrow = 1, ncol = 9)

filepath <- paste0(out_path, "/forest_plot", ".png")
png(file = filepath)
grid.arrange(grobs = forest_plots,
              nrow = 1, ncol = length(forest_plots))
dev.off()

```



#### Table of p values for all zeta orders
```{r}

grid.arrange(grobs = p_tables,
              nrow = 1, ncol = 9)

filepath <- paste0(out_path, "/forest_plot_p_values", ".png")
png(file = filepath)
grid.arrange(grobs = p_tables,
              nrow = 1, ncol = 9)
dev.off() 
```

#### Check if we can retrieve the same ispline plots
```{r}
my_msgdm_i <- my_msgdms[[1]]

my_data.env <- my_data$site.by.env

my_isplines <- Return.ispline(msgdm = my_msgdm_i, data.env = my_data.env, distance = TRUE)

# These two are almost identical except that the quantiles for distance are 
# slightly different
Plot.ispline(msgdm = my_msgdm_i, data.env = my_data.env, distance = TRUE)
Plot.ispline(isplines = my_isplines)

str(my_isplines, max.level = 1)
str(my_msgdms, max.level = 1)

isp_env <- my_isplines$env

head(my_isplines$Ispline)
```

